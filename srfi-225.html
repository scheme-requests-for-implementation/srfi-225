<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SRFI 225: Dictionaries</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1"></head>
  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI surfboard logo" /></a>225: Dictionaries</h1>

<p>by John Cowan (spec) and Arvydas Silanskas (implementation)</p>

<h2 id="status">Status</h2>

<p>This SRFI is currently in <em>draft</em> status.  Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+225+at+srfi+dotschemers+dot+org">srfi-225@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-225">archive</a>.</p>
<ul>
  <li>Received: 2021-06-26</li>
  <li>60-day deadline: 2021-09-16</li>
  <li>Draft #1 published: 2021-07-18</li>
  <li>John Cowan's <a href="https://github.com/pre-srfi/dictionaries">personal
    Git repo for this SRFI</a> for reference while the SRFI is in
    <em>draft</em> status (<a href="https://htmlpreview.github.io/?https://github.com/johnwcowan/srfi-225/blob/master/srfi-225.html">preview</a>)</li>
</ul>

<h2 id="abstract">Abstract</h2>

<p>The procedures of this SRFI allow callers to
manipulate an object that maps keys to values
without the caller needing to know exactly what the type
of the object is.  Such an object is called a <em>dictionary</em> in this SRFI.</p>

<h2 id="issues">Issues</h2>

None at present.

<h2 id="rationale">Rationale</h2>

<p>Until recently there was only one universally available mechanism for managing key-value pairs: alists. Most Schemes also support hash tables, but until R6RS there was no standard interface to them, and many implementations do not provide that interface.</p>
<p>Now, however, the number of such mechanisms is growing. In addition to both R6RS and R7RS hash tables, there are persistent ordered and hashed mappings from SRFI 146 and ordered key-value stores (often on a disk or a remote machine) from SRFI 167.</p>
<p>It’s inconvenient for users if SRFIs or other libraries have to insist on accepting only a specific type of dictionary. This SRFI exposes a number of accessors, mutators, and other procedures that can be called on any dictionary, provided that a <em>dictionary type descriptor</em> (DTD, with apologies to SGML and XML users) is available for it: either exported from this SRFI, or from other SRFIs or libraries, or created by the user. DTDs are of an unspecified type.</p>
<p>This in turn requires that the DTD provides a predicate that can recognize its dictionaries, plus at least these primitive operations: create an empty dictionary from a comparator; determine a dictionary’s current size; reference, update, or insert an element of the dictionary depending on its current contents; map over all the elements with a function mapping each old value to a new one; filter the elements based on their keys or values; and process all the elements using a procedure invoked for its side effects.</p>
<p>By using the procedures of this SRFI, a procedure can take a DTD and a dictionary as an argument and make flexible use of the dictionary without knowing its exact type.</p>
<p>Note that dictionaries must still be constructed using type-specific constructors, as the required and optional arguments differ in each case.</p>
<h2 id="specification">Specification</h2>
<p>We call a specific key-value combination an <em>association</em>. This is why an alist, or association list, is called that; it is a list of associations represented as pairs.</p>
<p>A <em>dictionary</em> is a collection of associations which may be ordered or unordered.  In principle an <em>equality predicate</em> is enough, given a key, to find if an association with that key exists in the dictionary.  However, for efficiency most dictionaries require an <em>ordering predicate</em> or a <em>hash function</em> as well.
<p>When a key argument is said to be the same as some key of the dictionary, it means that they are the same in the sense of the dictionary’s implicit or explicit equality predicate. It is assumed that no dictionary contains two keys that are the same in this sense.
Two dictionaries are <i>similar</i> if they are of the same type and have the same equality predicate and the same ordering predicate and/or hash function.</p>
<h3 id="lists-as-dictionaries">Lists as dictionaries</h3>
<p>Lists are supported as dictionaries using the specification in this section. If two keys are the same (in the sense of the specified equality predicate), then all but the first are treated as if they did not exist.</p>
<p>If <code>plist-dtd</code> (see below) is used with a list, then the list is assumed to be a property list, alternating symbol keys with values. Mutation operations actually mutate the property list whenever possible. The equality predicate of this type of dictionary is <code>eq?</code>.</p>
<p>If a list is empty, or its car is a pair, then the list can be treated as an alist. New values are added to the beginning of an alist and the new alist is returned; deletion does not mutate the alist, but returns an alist that may or may not share storage with the original alist. If an association has been updated, then both the new and the old association may be processed by the whole-dictionary procedures.  The examples in this SRFI use alists.</p>
<p>However, an alist (unlike a hashtable or mapping) does not know which equality predicate its users intend to use on it.  Therefore, rather than exporting a single DTD for alists, this SRFI provides a procedure <code>make-alist-dtd</code> takes an equality predicate and returns a DTD specialized for manipulation of alists using that predicate.</p>
<p>In all other cases, lists cannot be treated as dictionaries unless a DTD exists.</p>
<h3>Procedures</h3>
<p>Each of the following examples is assumed to be prefixed by the following definitions:</p>
<blockquote><pre>(define dict (list '(1 . 2) '(3 . 4) '(5 . 6)))
(define aed alist-eqv-dtd)
</pre></blockquote>
Consequently, previous examples don't affect later ones.
<p>The <em>dtd</em> argument is not discussed in the individual procedure descriptions below, but it is an error if invoking the <code>dictionary?</code> procedure that was used to make the DTD on <em>dictionary</em> returns <code>#f</code>.</p>
<h3 id="constructor">Constructor</h3>
<p><code>(make-dict</code>&nbsp;<em>dtd comparator obj</em> ...<code>)</code></p>
<p>Returns an empty dictionary of the type described by the DTD using <em>comparator</em> to specify to specify the dictionary's equality predicate and its ordering predicate and/or hash function.</p>
<p>The meaning of the other arguments depends on the type of dictionary being created.  However, implementations which support the ability to specify the initial capacity of a hash table should interpret a non-negative exact integer as the specification of that capacity.  In addition, if the symbols <code>thread-safe</code>, <code>weak-keys</code>, <code>ephemeral-keys</code>, <code>weak-values</code>, or <code>ephemeral-values</code> are present, implementations should create thread-safe hash tables, hash tables with weak keys or ephemeral keys, or hash tables with weak or ephemeral values respectively. Implementations are free to use ephemeral keys or values when weak keys or values respectively have been requested.</p>
<h3 id="predicates">Predicates</h3>
<p><code>(dictionary?</code>&nbsp;<em>dtd obj</em><code>)</code></p>
<p>Returns <code>#t</code> if <em>obj</em> answers <code>#t</code> to some registered predicate, and <code>#f</code> otherwise.</p>
<blockquote><pre>(define dict (list '(1 . 2) '(3 . 4) '(5 . 6)))
(dictionary? aed dict) =&gt; #t</pre></blockquote>
<p><code>(dict-empty?</code>&nbsp;<code>)</code></p>
<p>Returns <code>#t</code> if <em>dictionary</em> contains no associations and <code>#f</code> if it does contain associations.</p>
<blockquote><pre>(dict-empty? &#39;()) =&gt; #t
(dict-empty? aed dict) =&gt; #f</pre></blockquote>
<p><code>(dict-contains?</code>&nbsp;<em>dtd dictionary key</em><code>)</code></p>
<blockquote><pre>(dict-contains? aed dict 1) =&gt; #t
(dict-contains? aed dict 2) =&gt; #f</pre></blockquote>
<p>Returns <code>#t</code> if one of the keys of <em>dictionary</em> is the same as <em>key</em>, and <code>#f</code> otherwise.</p>
<h3 id="lookup">Lookup</h3>
<p><code>(dict-ref</code>&nbsp;<em>dtd dictionary key</em> [<em>failure</em> [<em>success</em>] ]<code>)</code></p>
<p>If <em>key</em> is the same as some key of <em>dictionary</em>, then invokes <em>success</em> on the corresponding value and returns its result. If <em>key</em> is not a key of <em>dictionary</em>, then invokes the thunk <em>failure</em> and returns its result. The default value of <em>failure</em> signals an error; the default value of <em>success</em> is the identity procedure.</p>
<blockquote><pre>(dict-ref aed dict 1 (lambda () &#39;()) list) =&gt; (1) ; Success wraps value in a list
(dict-ref aed dict 2 (lambda () &#39;()) list) =&gt; ()  ; Failure returns empty list</pre></blockquote>
<p><code>(dict-ref/default</code>&nbsp;<em>dtd dictionary key default</em><code>)</code></p>
<p>If <em>key</em> is the same as some key of <em>dictionary</em> then returns the corresponding value. If not, then returns <em>default</em>.</p>
<blockquote><pre>(dict-ref/default aed dict 1 #f) =&gt; 1
(dict-ref/default aed dict 1 #f) =&gt; #f</pre></blockquote>
<h3 id="mutation">Mutation</h3>
<p>All these procedures exist in pairs, with and without a final <code>!</code>.  The ones without <code>!</code> are functional: they never side-effect their arguments, but may copy them.  The ones with <code>!</code> are linear-update: they may return either a new dictionary object (which may or may not share storage with the <em>dictionary</em> argument), or the same dictionary object, mutated; in either case it is an error to access the dictionary later through any other reference to it, as that reference may have been invalidated.</p>
<p><code>(dict-set</code>&nbsp;<em>dtd dictionary obj</em> …<code>)</code><br>
<code>(dict-set!</code>&nbsp;<em>dtd dictionary obj</em> …<code>)</code></p>
<p>Returns a dictionary that contains all the associations of <em>dictionary</em> plus those specified by <em>objs</em>, which alternate between keys and values. If a key to be added already exists in <em>dictionary</em>, the new value prevails.</p>
<blockquote><pre>; new values are prepended
(dict-set aed dict 7 8) =&gt; ((7 . 8) (1 . 2) (3 . 4) (5 . 6))
(dict-set aed dict 3 5) =&gt; ((3 . 5) (1 . 2) (3 . 4) (5 . 6)</pre></blockquote>
<p><code>(dict-adjoin</code>&nbsp;<em>dtd dictionary objs</em><code>)</code><br>
<code>(dict-adjoin!</code>&nbsp;<em>dtd dictionary objs</em><code>)</code></p>
<p>Returns a dictionary that contains all the associations of <em>dictionary</em> plus those specified by <em>objs</em>, which alternate between keys and values. If a key to be added already exists in <em>dictionary</em>, the old value prevails.</p>
<blockquote><pre>; new values are prepended to alists
(dict-adjoin aed dict 7 8) =&gt; ((7 . 8) (1 . 2) (3 . 4) (5 . 6))
(dict-adjoin aed dict 3 5) =&gt; ((1 . 2) (3 . 4) (5 . 6)</pre></blockquote>
<p><code>(dict-delete</code>&nbsp;<em>dtd dictionary key</em> …<code>)</code><br>
<code>(dict-delete!</code>&nbsp;<em>dtd dictionary key</em> …<code>)</code></p>
<p>Returns a dictionary that contains all the associations of <em>dictionary</em> except those whose keys are the same as one of the <em>keys</em>.</p>
<blockquote><pre>; new values are prepended
(dict-delete aed dict 1 3) =&gt; ((5. 6)) ; may share
(dict-delete aed dict 5) =&gt; ((1 . 2) (3 . 4)</pre></blockquote>
<p><code>(dict-delete-all</code>&nbsp;<em>dtd dictionary keylist</em><code>)</code><br>
<code>(dict-delete-all!</code>&nbsp;<em>dtd dictionary keylist</em><code>)</code></p>
<p>Returns a dictionary with all the associations of <em>dictionary</em> except those whose keys are the same as some member of <em>keylist</em>.</p>
<blockquote><pre>(dict-delete-all aed dict &#39;(1 3)) =&gt; ((5 . 6))</pre></blockquote>
<p><code>(dict-replace</code>&nbsp;<em>dtd dictionary key value</em><code>)</code><br>
<code>(dict-replace!</code>&nbsp;<em>dtd dictionary key value</em><code>)</code></p>
<p>Returns a dictionary that contains all the associations of <em>dictionary</em> except as follows: If <em>key</em> is the same as a key of <em>dictionary</em>, then the association for that key is omitted and replaced by the association defined by the pair <em>key</em> and <em>value</em>. If there is no such key in <em>dictionary</em>, then dictionary is returned unchanged.</p>
<blockquote><pre>(dict-replace aed dict 1 3) =&gt; ((1 . 3) (1 . 2) (3 . 4) (5 . 6)) </pre></blockquote>
<p><code>(dict-intern</code>&nbsp;<em>dtd dictionary key failure</em>)<br>
<code>(dict-intern!</code>&nbsp;<em>dtd dictionary key failure</em>)</p>
<p>If there is a key in <em>dictionary</em> that is the same as <em>key</em>, returns two values, <em>dictionary</em> and the value associated with <em>key</em>.
Otherwise, returns two values, a dictionary that contains all the associations of <em>dictionary</em> and in addition a new association that maps <em>key</em> to the result of invoking <em>failure</em>, and the result of invoking <em>failure</em>.<br>
<blockquote><pre>(dict-intern aed dict 1 (lambda () #f)) =&gt; ; 2 values
  ((1 . 2) (3 . 4) (5 . 6))
  3
(dict-intern aed dict 2 (lambda () #f)) =&gt; ; 2 values
  ((2 . #f) (1 . 2) (3 . 4) (5 . 6))
  #f</pre></blockquote>
<p><code>(dict-update</code>&nbsp;<em>dtd dictionary key updater</em> [<em>failure</em> [<em>success</em>] ]<code>)</code></p>
<p><code>(dict-update!</code>&nbsp;<em>dtd dictionary key updater</em> [<em>failure</em> [<em>success</em>] ]<code>)</code></p>
<p>Retrieves the value of <em>key</em> as if by <code>dict-ref</code>, invokes <em>updater</em> on it, and sets the value of <em>key</em> to be the result of calling <em>updater</em> as if by <code>dict-set</code>, but may do so more efficiently. Returns the updated dictionary. The default value of <em>failure</em> signals an error; the default value of <em>success</em> is the identity procedure.</p>
<p><code>(dict-update/default</code>&nbsp;<em>dtd dictionary key updater default</em><code>)</code></p>
<p><code>(dict-update/default!</code>&nbsp;<em>dtd dictionary key updater default</em><code>)</code></p>
<p>Retrieves the value of <em>key</em> as if by <code>dict-ref/default</code>, invokes <em>updater</em> on it, and sets the value of <em>key</em> to be the result of calling <em>updater</em> as if by <code>dict-set</code>, but may do so more efficiently. Returns the updated dictionary.</p>
<p><code>(dict-pop</code>&nbsp;<em>dtd dictionary</em><code>)</code><br>
<code>(dict-pop!</code>&nbsp;<em>dtd dictionary</em><code>)</code></p>
<p>Chooses an association from <em>dictionary</em> and returns three values: a dictionary that contains all associations of <em>dictionary</em> except the chosen one, and the key and the value of the chosen association. If the dictionary is ordered, the first association is chosen; otherwise the chosen association is arbitrary.</p>
<p>If dictionary contains no associations, it is an error.</p>
<blockquote><pre>(dict-pop aed dict) =&gt; # 3 values
  ((3 . 4) (5 . 6))
  1
  2</pre></blockquote>
<p><code>(dict-map</code>&nbsp;<em>dtd proc dictionary</em><code>)</code><br>
<code>(dict-map!</code>&nbsp;<em>dtd proc dictionary</em><code>)</code></p>
<p>Returns a dictionary similar to <em>dictionary</em> that maps each key of <em>dictionary</em> to the value that results from invoking <em>proc</em> on the corresponding key and value of <em>dictionary</em>.</p>
<blockquote><pre>(dict-map (lambda (k v) (cons v k)) aed dict) =&gt; ((2 . 1) (4 . 3) (6 . 5))</pre></blockquote>
<blockquote><pre>(dict-map! (lambda (k v) (cons v k)) aed dict) =&gt; ((2 . 1) (4 . 3) (6 . 5))</pre></blockquote>
<p><code>(dict-filter</code>&nbsp;<em>dtd pred dictionary</em><code>)</code><br>
<code>(dict-filter!</code>&nbsp;<em>dtd pred dictionary</em><code>)</code></p>
<p>Returns a dictionary similar to <em>dictionary</em> that contains just the associations of <em>dictionary</em> that satisfy <em>pred</em> when it is invoked on the key and value of the association.</p>
<blockquote><pre>(dict-filter (lambda (k v) (= k 1)) aed dict) =&gt; ((1 . 2))</pre></blockquote>
<p><code>(dict-remove</code>&nbsp;<em>dtd pred dictionary</em><code>)</code><br>
<code>(dict-remove!</code>&nbsp;<em>dtd pred dictionary</em><code>)</code></p>
<p>Returns a dictionary that contains all the associations of <em>dictionary</em> except those that satisfy <em>pred</em> when called on the key and value.</p>
<blockquote><pre>(dict-remove (lambda (k) (= k 1)) aed dict) =&gt; ((3 . 4) (5 . 6))</pre></blockquote>
<p><code>(dict-search</code>&nbsp;<em>dtd dictionary key failure success</em><code>)</code><br>
<code>(dict-search!</code>&nbsp;<em>dtd dictionary key failure success</em><code>)</code></p>
<p>This procedure is a workhorse for dictionary lookup, insert, and delete. The dictionary <em>dictionary</em> is searched for an association whose key is the same as <em>key</em> in the sense of <em>dictionary</em>. If one is not found, then the <em>failure</em> procedure is tail-called with two procedure arguments, <em>insert</em> and <em>ignore</em>, and is expected to tail-call one of them.</p>
<p>However, if such an association is found, then the <em>success</em> procedure is tail-called with the matching key of <em>dictionary</em>, the associated value, and two procedure arguments, <em>update</em> and <em>remove</em>, and is expected to tail-call one of them.</p>
<p>It is an error if the procedure arguments are invoked other than in tail position in the <em>failure</em> and <em>success</em> procedures. It is also an error if the <em>failure</em> and <em>success</em> procedures return to their implicit continuation without invoking one of their arguments.</p>
<p>The behaviors of the procedures are as follows (where <em>obj</em> is any Scheme object):</p>
<ul>
<li><p>Invoking <code>(</code><em>insert value obj</em><code>)</code> returns a dictionary that contains all the associations of <em>dictionary</em>, and in addition a new association that maps <em>key</em> to <em>value</em>.</p></li>
<li><p>Invoking <code>(</code><em>ignore obj</em><code>)</code> has no effects and returns <em>dictionary</em> unchanged.</p></li>
<li><p>Invoking <code>(</code><em>update new-key new-value obj</em><code>)</code> returns a dictionary that contains all the associations of <em>dictionary</em>, except for the association whose key is the same as <em>key</em>, which is replaced or hidden by a new association that maps <em>new-key</em> to <em>new-value</em>. It is an error if <em>key</em> and <em>new-key</em> are not the same in the sense of the dictionary’s equality predicate.</p></li>
<li><p>Invoking <code>(</code><em>remove obj</em><code>)</code> returns a dictionary that contains all the associations of <em>dictionary</em>, except for the association with key key.</p></li>
</ul>
<p>In all cases, <em>obj</em> is returned as a second value.</p>
<p>Here are four examples of <code>dict-search</code>,
one for each of the four procedures:
<blockquote><pre>
     ;; ignore
     (define-values
       (dict value)
       (dict-search (alist->dict '((a . b))) 'c
              (lambda (insert ignore)
                (ignore 'foo))
              (lambda args
                (error))))
     (dict->alist aed dict)) => ((a . b))
     value => 'foo

     ;; insert
     (define-values
       (dict value)
       (dict-search (alist->dict '((a . b))) 'c
              (lambda (insert ignore)
                (insert 'd 'foo))
              (lambda args
                (error))))
     (dict-ref aed dict 'a)) => b
     (dict-ref aed dict 'c)) => 'd`
     value => foo

     ;; update
     (define-values
       (dict value)
       (dict-search (alist->dict '((a . b))) 'a
              (lambda args
                (error))
              (lambda (key value update delete)
                (update 'a2 'b2 'foo))))
     (dict->alist aed dict) => ((a2 . b2)
     value => foo

     ;; delete
     (define-values
       (dict value)
       (dict-search (alist->dict '((a . b) (c . d))) 'a
              (lambda args
                (error))
              (lambda (key value update delete)
                (delete 'foo))))
     (dict->alist aed dict)) => ((c . d))
     value => foo
</pre></blockquote>
<h3 id="the-whole-dictionary">The whole dictionary</h3>
<p><code>(dict-copy</code>&nbsp;<em>dtd dictionary</em><code>)</code><p>
Returns a dictionary that is similar to <em>dictionary</em> and contains the same associations.  Mutating the result of <code>dict-copy</code> does not affect <em>dictionary</em> or vice versa.</p>
<p><code>(dict-size</code>&nbsp;<em>dtd dictionary</em><code>)</code></p>
<p>Returns an exact integer representing the number of associations in <em>dictionary</em>.</p>
<blockquote><pre>(dict-size aed dict) =&gt; 3</pre></blockquote>
<p><code>(dict-for-each</code>&nbsp;<em>dtd proc dictionary</em><code>)</code></p>
<p>Invokes <em>proc</em> on each key of <em>dictionary</em> and its corresponding value in that order. This procedure is used for doing operations on the whole dictionary. If the dictionary type is inherently ordered, associations are processed in the inherent order; otherwise in an arbitrary order. Returns an unspecified value.</p>
<blockquote><pre>(define (write-key key value) (write key))
(dict-for-each write-key aed dict) =&gt; unspecified
  ; writes &quot;135&quot; to current output</pre></blockquote>
<p><code>(dict-count</code>&nbsp;<em>dtd pred dictionary</em><code>)</code></p>
<p>Passes each association of dictionary as two arguments to <em>pred</em> and returns the number of times that <em>pred</em> returned true as an an exact integer.</p>
<blockquote><pre>(dict-count aed dict (lambda (k v) (even? k))) =&gt; 0</pre></blockquote>
<p><code>(dict-any</code>&nbsp;<em>dtd pred dictionary</em><code>)</code></p>
<p>Passes each association of <em>dictionary</em> as two arguments to <em>pred</em> and returns the value of the first call to <em>pred</em> that returns true, after which no further calls are made. If the dictionary type is inherently ordered, associations are processed in the inherent order; otherwise in an arbitrary order. If all calls return false, <code>dict-any</code> returns false.</p>
<blockquote><pre>(define (both-even? k v) (and (even? k) (even? v)))
(dict-any both-even? &#39;((2 . 4) (3 . 5))) =&gt; #t
(dict-any both-even? &#39;((1 . 2) (3 . 4))) =&gt; #f</pre></blockquote>
<p><code>(dict-every</code>&nbsp;<em>dtd pred dictionary</em><code>)</code></p>
<p>Passes each association of <em>dictionary</em> as two arguments to <em>pred</em> and returns <code>#f</code> after the first call to <em>pred</em> that returns false, after which no further calls are made. If the dictionary type is inherently ordered, associations are processed in the inherent order; otherwise in an arbitrary order. If all calls return true, <code>dict-any</code> returns the value of the last call, or <code>#t</code> if no calls are made.</p>
<blockquote><pre>(define (some-even? k v) (or (even? k) (even? v)))
(dict-every some-even? &#39;((2 . 3) (3 . 4))) =&gt; #t
(dict-every some-even? &#39;((1 . 3) (3 . 4))) =&gt; #f</pre></blockquote>
<p><code>(dict-keys</code>&nbsp;<em>dtd dictionary</em><code>)</code></p>
<p>Returns a list of the keys of <em>dictionary</em>. If the dictionary type is inherently ordered, associations are processed in the inherent order; otherwise in an arbitrary order. The order may change when new elements are added to <em>dictionary</em>.</p>
<blockquote><pre>(dict-keys aed dict) =&gt; (1 3 5)</pre></blockquote>
<p><code>(dict-values</code>&nbsp;<em>dtd dictionary</em><code>)</code></p>
<p>Returns a list of the values of <em>dictionary</em>. The results returned by <code>dict-keys</code> and <code>dict-values</code> are not necessarily ordered consistently.</p>
<blockquote><pre>(dict-values aed dict) =&gt; (2 4 6)</pre></blockquote>
<p><code>(dict-entries</code>&nbsp;<em>dtd dictionary</em><code>)</code></p>
<p>Returns two values, the results of calling <code>dict-keys</code> and the result of calling <code>dict-values</code> on <em>dictionary</em>.</p>
<blockquote><pre>(dict-entries aed dict) =&gt; ; 2 values
  (1 3 5)
  (2 4 6)</pre></blockquote>
<p><code>(dict-fold</code>&nbsp;<em>dtd proc knil dictionary</em><code>)</code></p>
<p>Invokes <em>proc</em> on each association of <em>dictionary</em> with three arguments: the key of the association, the value of the association, and an accumulated result of the previous invocation. For the first invocation, <em>knil</em> is used as the third argument. Returns the result of the last invocation, or <em>knil</em> if there was no invocation.  Note that there is no guarantee of a consistent result if the dictionary does not have an inherent order.</p>
<blockquote><pre>(dict-fold + 0 &#39;((1 . 2) (3 . 4))) =&gt; 10</pre></blockquote>
<p><code>(dict-map-&gt;list</code>&nbsp;<em>dtd proc dictionary</em><code>)</code></p>
<p>Returns a list of values that result from invoking <em>proc</em> on the keys and corresponding values of <em>dictionary</em>.</p>
<blockquote><pre>
(dict-map->list (lambda (k v) v) dict) =>gt; (2 4 6),
(dict-map->list - aed dict) =&gt; (-1 -1 -1) ; subtract value from key
</pre></blockquote>
<p><code>(dict-&gt;alist</code>&nbsp;<em>dtd dictionary</em><code>)</code></p>
<p>Returns an alist whose keys and values are the keys and values of <em>dictionary</em>.</p>
<blockquote><pre>; plist to alist
(dict-&gt;alist &#39;(1 2 3 4 5 6)) =&gt; ((1 . 2) (3 . 4) (5 . 6))</pre></blockquote>
<p>Add <code>dict-map</code>,
<code>dict-filter</code>, <code>dict-remove</code>,
and <code>dict-search</code>.
</p>
<p><code>(dict-comparator</code>&nbsp<em>dtd dictionary</em><code>)</code></p>
<h3 id="dictionary-type-descriptors">Dictionary type descriptors</h3>
<p><code>(dtd?</code>&nbsp;<em>obj</em><code>)</code></p>
<p>Returns <code>#t</code> if <em>obj</em> is a DTD, and <code>#f</code> otherwise.</p>
<p><code>(make-dtd</code>&nbsp;<em>arg</em> …<code>)</code></p>
<p>Returns a new dictionary type providing procedures that allow manipulation of dictionaries of that type. The <em>args</em> are alternately <em>procnames</em> and corresponding <em>procs</em>.</p>
<p>A <em>procname</em> argument is a symbol which is the same as one of the procedures defined in this SRFI (other than those in this section), and a <em>proc</em> argument is the specific procedure implementing it for this type. These procedures only need to handle a full-length argument list (except when defining <code>dict-ref</code> and <code>dict-update!</code>), as the other defaults have already been supplied by the framework.</p>
<p>
<i>Shrink this list if possible:</i>
Arguments for the seven procedures <code>make-dict</code>, <code>dictionary?</code>, <code>dict-size</code>, <code>dict-search!</code>, <code>dict-map!</code>, <code>dict-filter!</code>, and <code>dict-for-each</code> are required. The others are optional, but if provided can be more efficient than the versions automatically provided by the implementation of this SRFI.</p>

<p>The following example is from the file <code>plist-impl.scm</code>
in the sample implementation; the procedures referred to are also in
that file.<p>
<blockquote><pre>
  (make-dtd
    'dictionary? plist?
    'dict-map! plist-map!
    'dict-filter! plist-filter!
    'dict-search! plist-search!
    'dict-size plist-size
    'dict-for-each plist-foreach
    'dict->alist plist->alist)) =&gt; a DTD for plists
</pre></blockquote>
<p><code>(make-alist-dtd</code>&nbsp;<em>equal</em><code>)</code></p>
<p>Returns a DTD for manipulating an alist using the equality predicate <em>equal</em>.</p>
<blockquote><code>(make-alist-dtd =) =&gt; a DTD for alists using numeric equality</code></blockquote>
<h3 id="exceptions">Exceptions</h3>
<p><code>dictionary-error</code>&nbsp;<em>message irritant</em> ... <code>)</code></p>
<p>Returns a dictionary error with the given <em>message</em> (a string) and
<em>irritants</em> (any objects).
If a particular procedure in a DTD cannot be implemented, it instead
should signal an appropriate dictionary exception that can be reliably caught.
<p><code>dictionary-error?</code>&nbsp;<em>obj</em><code>)</code></p>
<p>Returns <code>#t</code> if <em>obj</em> is a dictionary error
and <code>#f</code> otherwise.
<p><code>dictionary-message</code>&nbsp<em>dictionary-error</em><code>)</code></p>
<p>Returns the message associated with <em>dictionary-error.</em></p>
<p><code>(dictionary-irritants</code>&nbsp<em>dictionary-error</em><code>)</code></p>
<p>Returns a list of the irritants associated with <em>dictionary-error</em>.</p>
<h3 id="variables">Variables</h3>
<p>The following DTDs are also exported from this SRFI:
<code>srfi-69-dtd</code>, <code>hash-table-dtd</code>, <code>srfi-126-dtd</code>,
<code>mapping-dtd</code>, <code>hash-mapping-dtd</code>, <code>plist-dtd</code>,
<code>alist-eqv-dtd</code>, and <code>alist-equal-dtd</code>.
The last two provide DTDs for alists using <code>eqv?</code>
and <code>equal?</code> respectively.</p>
<h2 id="implementation">Implementation</h2>

<p>The sample implementation is found in the GitHub repository.</p>
<h2 id="acknowledgements">Acknowledgements</h2>

<p>Thanks to the participants on the mailing list.</p>

<h2 id="copyright">Copyright</h2>
<p>&copy; 2021 John Cowan, Arvydas Silanskas.</p>

<p>
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:</p>

<p>
  The above copyright notice and this permission notice (including the
  next paragraph) shall be included in all copies or substantial
  portions of the Software.</p>
<p>
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.</p>

  <hr>
  <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>
